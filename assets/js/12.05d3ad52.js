(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{216:function(n,s,a){"use strict";a.r(s);var t=a(0),e=Object(t.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-执行堆栈探索"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-执行堆栈探索"}},[n._v("#")]),n._v(" JavaScript 执行堆栈探索")]),n._v(" "),a("h2",{attrs:{id:"引言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[n._v("#")]),n._v(" 引言")]),n._v(" "),a("p",[n._v("JavaScript 代码执行的时候会将不同的变量存于内存中不同的位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则着一些基础类型变量以及对象的指针。但是我们这说的执行栈和上面的这个栈的意义有些不同。js 在执行可执行的的脚本时，首先会创建一个全局可执行上下文 globalContext，每当执行到一个函数调用时都会创建一个可执行上下文（execution context）EC。当然可执行程序可能会存在很多函数调用，那么就会创建很多 EC，，所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。当函数调用完成，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境...这个过程反复执行，直到执行栈中的代码全部执行完毕。")]),n._v(" "),a("h2",{attrs:{id:"来观看一个例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#来观看一个例子"}},[n._v("#")]),n._v(" 来观看一个例子")]),n._v(" "),a("p",[n._v("以下为网上一个非常经典的面试题:")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var a = {n: 1}  \nvar b = a;  \na.x = a = {n: 2}  \nconsole.log(a.x);  \nconsole.log(b.x) \n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("分析过程：")]),n._v(" "),a("p",[n._v("1.b = a 是浅拷贝，所以在堆栈中引用的是一个对象地址。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E6%B5%85%E6%8B%B7%E8%B4%9D.png",alt:""}})]),n._v(" "),a("p",[n._v("2.var a=1，b=2，c=3；")]),n._v(" "),a("p",[n._v("a = b = c；")]),n._v(" "),a("p",[n._v("输出的 a，b，c 结果都为 3。  因为赋值运算从右向左执行。")]),n._v(" "),a("p",[n._v("而我们这道题 a.x = a = {n: 2}")]),n._v(" "),a("p",[n._v(". 的运算优先级大于赋值运算的优先级。")]),n._v(" "),a("p",[n._v("所以先计算")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E8%BF%90%E7%AE%97%E7%AC%A6.png",alt:""}})]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E5%A0%86%E6%A0%881.png",alt:""}})]),n._v(" "),a("p",[n._v("再计算")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E8%BF%90%E7%AE%97%E7%AC%A62.png",alt:""}})]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E5%A0%86%E6%A0%882.png",alt:""}})]),n._v(" "),a("h3",{attrs:{id:"堆和栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈"}},[n._v("#")]),n._v(" 堆和栈")]),n._v(" "),a("p",[n._v("内存栈：函数执行的时候会把局部变量压到一个栈里面。")]),n._v(" "),a("p",[n._v("内存堆：是指存放 new 出来动态变量的地方")]),n._v(" "),a("p",[n._v("爆栈与死循环区别")]),n._v(" "),a("p",[n._v("造成形象是一样的")]),n._v(" "),a("p",[n._v("（1） 死循环系统主 UI 线程已经没有时间处理微任务与宏任务。")]),n._v(" "),a("p",[n._v("（2） 爆栈是分配的栈空间用光了。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E5%A0%86%E6%A0%882.jpg",alt:""}})]),n._v(" "),a("p",[n._v("1、栈区(stack):又编译器自动分配释放，存放函数的参数值，局部变量 的值等，其操作方式类似于数据结构的栈。")]),n._v(" "),a("p",[n._v("2、堆区(heap):一般是由程序员分配释放，若程序员不释放的话，程 序结束时可能由 OS 回收，值得注意的是他与数据结构的堆是两回事，分配方式 倒是类似于数据结构的链表。")]),n._v(" "),a("p",[n._v("3、全局区(static):也叫静态数据内存空间，存储全局变量和静态变 量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放 一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。")]),n._v(" "),a("p",[n._v("4、文字常量区:常量字符串就是放在这里，程序结束后由系统释放。 5、程序代码区:存放函数体的二进制代码。")]),n._v(" "),a("p",[n._v("⚠️注意 申请的 buffer 空间并不是堆区栈区去管理的，是由 C 底层管理。变量是由 JS 管理的。")]),n._v(" "),a("p",[n._v("##闭包")]),n._v(" "),a("p",[n._v("面试经常问什么是闭包")]),n._v(" "),a("p",[n._v("严格意义上说保留一个执行的词法作用域就是闭包。")]),n._v(" "),a("p",[n._v("下面来看个列子：")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" <script>\n        (function() {\n            debugger\n        })()\n    <\/script>\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("执行上面代码会形成如图")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/%E9%97%AD%E5%8C%851.png",alt:""}})]),n._v(" "),a("p",[n._v("会形成两个闭包，为什么呢")]),n._v(" "),a("p",[n._v("一个闭包可以理解为 js 的入口函数，c 语言中有个 main，")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("main(){}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br")])]),a("p",[n._v("在这里可以理解为 js 的 mian，js 的执行环境就是一个闭包，其实就是可以认为下面代码就是闭包。")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function test(){\n}\ntest()\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("总结其实闭包就是个概念")]),n._v(" "),a("h2",{attrs:{id:"执⾏栈-execution-context-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执⾏栈-execution-context-stack"}},[n._v("#")]),n._v(" [执⾏栈(Execution Context Stack)]")]),n._v(" "),a("p",[n._v("浏览器器解释器器执⾏ js 是单线程的过程，这就意味着同一时间，只能有⼀个事情在进⾏。其他的活动和事件只能排队等候，⽣成出⼀个等候队列执行栈(Execution Stack)。")]),n._v(" "),a("p",[n._v("1.执行栈 -----》ECS（Execution Context Stack)")]),n._v(" "),a("p",[n._v("2.每一个函数都会创建一个 EC")]),n._v(" "),a("p",[n._v("3.每一个函数执行的时候都会把自己塞进到 ECS")]),n._v(" "),a("p",[n._v("4.全局对象----》GC（Global Context）")]),n._v(" "),a("h3",{attrs:{id:"执⾏栈压栈顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执⾏栈压栈顺序"}},[n._v("#")]),n._v(" 执⾏栈压栈顺序")]),n._v(" "),a("p",[n._v("一开始执行代码的时候便确定一个全局执行上下文（Global execution context）作为默认值，如果在全局环境中，调用了其他函数，程序将会创建一个新的 EC，然后将 EC 推入进执行栈中 execution stack。")]),n._v(" "),a("p",[n._v("如果函数再调用其他函数，相同的步骤将会再次发生：创建⼀一个新的 EC -> 把 EC 推⼊执⾏栈。⼀旦⼀ 个 EC 执⾏完成，变回从执行栈中推出(pop)。")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \nECStack = [\n•    globalContext\n];\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("h3",{attrs:{id:"_1-继续分析压栈过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-继续分析压栈过程"}},[n._v("#")]),n._v(" 1. 继续分析压栈过程")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \nfunction fun3() {plainplainplainplainplainplainplainplain\n    console.log('fun3')\n}\nfunction fun2() {\nfun3(); }\nfunction fun1() {\n    fun2();\n}\nfun1(); \n//执⾏行行fun1 结果如下 ECStack = [\n    fun1,\n    globalContext\n];\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br")])]),a("h3",{attrs:{id:"_2-变量对象-variable-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-变量对象-variable-object"}},[n._v("#")]),n._v(" 2. 变量对象 (Variable Object)")]),n._v(" "),a("p",[n._v("变量对象 VO 是与执⾏上下文相关的特殊对象,⽤来存储上下文的函数声明，函数形参和变量。")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \n//变量对象VO存储上下⽂中声明的以下内容 \n{plainplainplain\n//1-1 函数声明FD(如果在函数上下文中),—-不不包含函数表达式\n//1-2 函数形参function arguments,\n//1-3 变量量声明–注意b=10不不是变量量，但是var b = 10;是变量量，有变量量声明提升 //alert(a); // undefined\n//alert(b); // “b” 没有声明\n//b = 10;\n//var a = 20;\n}\nvar a = 10;\nfunction test(x) {\n  var b = 20;\n}; test(30);\n// 全局上下⽂文的变量量对象 \nVO(globalContext) = {\n   a: 10,\n  test: <reference to function>\n};\n// test函数上下⽂文的变量量对象 \nVO(test functionContext) = {\nx: 30,\nb: 20 };\n//VO分为 全局上下⽂文的变量量对象VO，函数上下⽂文的变量量对象VO VO(globalContext) === global;\n \n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br")])]),a("h3",{attrs:{id:"_3-活动对象-activation-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-活动对象-activation-object"}},[n._v("#")]),n._v(" 3. 活动对象(Activation Object)")]),n._v(" "),a("p",[n._v("在函数上下⽂中，变量对象被表示为活动对象 AO,当函数被调用后，这个特殊的活动对象就被创建了了。 它包含普通参数与特殊参数对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//1.在函数执⾏上下文中，VO是不能直接访问的，此时由活动对象扮演VO的角色。 \n//2.Arguments对象它包括如下属性:callee 、length\n//3.内部定义的函数\n//4.以及绑定上对应的变量量环境;plainplainplainplainplainplain\n//5.内部定义的变量\n VO(functionContext) === AO; function test(a, b) {\n  var c = 10;\n  function d() {}\n  var e = function _e() {};\n  (function x() {});\n}\ntest(10); \n// call\n当进⼊入带有参数10的test函数上下⽂文时，AO表现为如下:\n\n//AO⾥并不包含函数“x”。这是因为“x” 是⼀个函数表达式(FunctionExpression, 缩写为 FE) ⽽不不 是函数声明，函数表达式不会影响VO\nAO(test) = {\n  a: 10,\n  b: undefined,\n  c: undefined,\n  d: <reference to FunctionDeclaration "d">\n  e: undefined\n};\n\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br")])]),a("h3",{attrs:{id:"_4-深度活动对象-activation-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-深度活动对象-activation-object"}},[n._v("#")]),n._v(" 4. 深度活动对象(Activation Object)")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \n//Activation Object 分为创建阶段和执⾏行行阶段 \nfunction foo(i) {\nvar a = 'hello';\n \nvar b = function privateB() {plainplainplain\n    };\n    function c() {\n    }\n}\nfoo(22); \n//当我们执⾏行行foo(22)的时候，EC创建阶段会类似⽣生成下⾯面这样的对象: \nfooExecutionContext = {\n    scopeChain: { Scope },\n    AO: {\n        arguments: {\n            0: 22,\nlength: 1 },\n        i: 22,\n        c: pointer to function c()\n        a: undefined,\n        b: undefined\n    },\n    VO:{..}\n    Scope: [AO, globalContext.VO],\n}\n//在创建阶段，会发⽣属性名称的定义，但是并没有赋值(变量量提升阶段)。\n//⼀旦创建阶段(creation stage)结束，变进⼊了激活 \n// 执⾏阶段，那么fooExecutionContext便便会完成赋值，变成这样: \n\n//【 运⾏函数内部的代码，对变量复制，代码一行一行的被解释执⾏ 】\nfooExecutionContext = {\n    scopeChain: { ... },\n    AO: {\n        arguments: {\n            0: 22,\nlength: 1 },\n        i: 22,\n        c: pointer to function c()\n        a: 'hello',\n        b: pointer to function privateB()\n},\nVO:{..}\nScope: [AO, globalContext.VO], this: { 运⾏行行时确认 }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br")])]),a("h3",{attrs:{id:"_5-补充活动对象-activation-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-补充活动对象-activation-object"}},[n._v("#")]),n._v(" 5. 补充活动对象(Activation Object)")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var x = 10;\nfunction foo() {\n  var barFn = Function('alert(x); alert(y);');\n  barFn(); // 10, \"y\" is not defined\n}\nfoo();plainplain\n//1.通过函构造函数创建的函数的[[scope]]属性总是唯⼀的全局对象(LexicalEnvironment)。 \n//2.Eval code - eval 函数包含的代码块也有同样的效果\n\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("h3",{attrs:{id:"_6-整合体运⾏行行流程如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-整合体运⾏行行流程如下"}},[n._v("#")]),n._v(" 6. 整合体运⾏行行流程如下")]),n._v(" "),a("div",{staticClass:"language-plain line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" \n//VO函数上下⽂的链接 AO是函数自身的 \nECStack = [\n        fun3\n        fun2,\n        fun1,\n        globalContextplainplainplainplainplain\n];\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);
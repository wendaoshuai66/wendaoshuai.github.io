(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{306:function(s,n,a){"use strict";a.r(n);var t=a(10),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"es5-的核心技术"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es5-的核心技术"}},[s._v("#")]),s._v(" ES5 的核心技术")]),s._v(" "),n("h2",{attrs:{id:"this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[s._v("#")]),s._v(" this")]),s._v(" "),n("h3",{attrs:{id:"为什么要用-this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-this"}},[s._v("#")]),s._v(" 为什么要用 this")]),s._v(" "),n("p",[s._v("直接上代码")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v(' function identify() {\n        return this.name.toUpperCase();\n      }\n      function speak() {\n        var greeting = "Hello, I\'m " + identify.call( this );\n        console.log( greeting)\n      }\n      var me = {\n        name: "Kyle"\n      };\n      var you = {\n        name: "Reader"\n      };\n      identify.call( me ); // KYLE\n      identify.call( you ); // READER\n      speak.call( me ); // Hello, 我是 KYLE\n      speak.call( you ); // Hello, 我是 READER\n      \n      如果不用this\n      function identify(context) {\n       return context.name.toUpperCase();\n      }\n      function speak(context) {\n       var greeting = "Hello, I\'m " + identify( context );\n       console.log( greeting );\n      }\n      identify( you ); // READER\n      speak( me ); //hello, 我是 KYLE\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br")])]),n("p",[s._v("this 提供了更优雅的隐式方式’传递‘一个对象的引用，可以将 API 设计的简洁易用复用")]),s._v(" "),n("h3",{attrs:{id:"this-并不像我们所想的那样指向函数本身"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-并不像我们所想的那样指向函数本身"}},[s._v("#")]),s._v(" this 并不像我们所想的那样指向函数本身")]),s._v(" "),n("p",[s._v("我们想要记录一下函数 foo 被调用的次数，思考一下下面的代码:")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v('      function foo(num) {\n      console.log( "foo: " + num );\n      // 记录 foo 被调用的次数\n      this.count++;\n      }\n      foo.count = 0;\n      var i;\n      for (i=0; i<10; i++) {\n        if (i > 5) {\n          foo( i );\n        }\n      }\n        foo: 6\n        foo: 7\n        foo: 8\n        foo: 9\n      console.log( foo.count );//0----\x3e为什么\n      \n      解决此的两种方法：\n      方法一：\n      function foo(num) {\n      console.log( "foo: " + num );\n      // 记录 foo 被调用的次数\n      foo.count++;\n      }\n      foo.count = 0;\n      var i;\n      for (i=0; i<10; i++) {\n        if (i > 5) {\n          foo( i );\n        }\n      }\n        foo: 6\n        foo: 7\n        foo: 8\n        foo: 9\n      console.log( foo.count )//4\n      方法二：\n      function foo(num) {\n        console.log( "foo: " + num );\n        // 记录 foo 被调用的次数\n        this.count++;\n      }\n      foo.count = 0;\n      var i;\n      for (i=0; i<10; i++) {\n        if (i > 5) {\n          foo.call(foo, i );\n        }\n      }\n      console.log(foo.count)\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br")])]),n("p",[s._v("执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同")]),s._v(" "),n("h3",{attrs:{id:"this-的作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-的作用域"}},[s._v("#")]),s._v(" this 的作用域")]),s._v(" "),n("p",[s._v("this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的")]),s._v(" "),n("blockquote",[n("p",[n("em",[s._v("需要明确的是，this 在任何情况下都不指向函数的词法作用域")])])]),s._v(" "),n("h3",{attrs:{id:"this-到底是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-到底是什么"}},[s._v("#")]),s._v(" this 到底是什么")]),s._v(" "),n("blockquote",[n("p",[n("em",[s._v("this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。")])])]),s._v(" "),n("h3",{attrs:{id:"this-调用位置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-调用位置"}},[s._v("#")]),s._v(" this 调用位置")]),s._v(" "),n("p",[s._v("调用位置就是函数在代码中被调用的位置（而不是声明的位置）,大白话谁调用指向谁")]),s._v(" "),n("h4",{attrs:{id:"this-谁调用指向谁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-谁调用指向谁"}},[s._v("#")]),s._v(" this 谁调用指向谁")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("this.a = 20;\nvar p={\n  a:30,\n  test:function(){\n  //this---\x3ep\n  alert(this.a)\n}\n}\n//s---\x3ewindow\nvar s =p.test;\ns()//20\n接着复杂\nthis.a = 20;\nvar p={\n  a:30,\n  test:function(){\n    //this---\x3ep\n    alert(this.a)\n    function s(){\n      this.a=60;\n      alert(this.a)\n    }\n    return s;\n  }\n}\n//s---\x3ewindow\nvar s =p.test();\ns()//60\n如果去掉this.a=60‘\ns()//20\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])]),n("h3",{attrs:{id:"this-绑定规则-默认绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-绑定规则-默认绑定"}},[s._v("#")]),s._v(" this 绑定规则--默认绑定")]),s._v(" "),n("p",[s._v("独立函数调用")]),s._v(" "),n("p",[s._v("声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n\tconsole.log(this.a)\n}\nvar a = 2;\nfoo()//2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("如果使用严格模式")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v('function foo() {\n"use strict";\nconsole.log( this.a );\n}\nvar a = 2;\nfoo();// TypeError: this is undefined\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("如果严格模式写成这样")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v('function foo() {\nconsole.log( this.a );\n}\nvar a = 2;\n(function () {\n"use strict";\nfoo()//2\n})()\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("总结：this 绑定规则完全取决于调用位置，但是只有 foo()运行在非 strict mode 默认绑定才能绑定到全局对象；严格模式下与 foo()的调用位置无关")]),s._v(" "),n("h3",{attrs:{id:"绑定规则-隐式绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则-隐式绑定"}},[s._v("#")]),s._v(" 绑定规则----隐式绑定")]),s._v(" "),n("p",[s._v("调用的位置是否有上下文对象，或者说是否被某个对象所拥有或者包含")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n    console.log( this.a );\n}\nvar obj={\n    a:1,\n    foo:foo\n}\nobj.foo();//1\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("调用位置会使用 obj 上下文来引用函数\n当函数引用有上下文的对象时，隐式绑定规则会把函数调用的this绑定到上下文对象\n对象引用链中只有最顶层或者说最后一层会影响调用的位置，废话不多说上代码\n\nfunction foo() {\n          console.log( this.a );\n      }\n      var obj2={\n          a:42,\n          foo:foo\n      }\n      var obj1={\n          a:2,\n          obj2:obj2\n      }\n      obj1.obj2.foo();//42\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("p",[s._v("一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而 this 绑定到全局对象或者说 undefined 取决于是否严格模式")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n    console.log(this.a)\n}\nvar obj = {\n    a:1,\n    foo:foo\n}\nvar s= obj.foo;//函数别名\nvar a='globle';//a是全局对象的属性\ns()//globle\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("传入回调函数 参数传递是隐式赋值")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v(" function foo() {\n      console.log(this.a)\n  }\n  function dofoo(fn) {\n      fn()\n  }\n  var obj={\n      a:1,\n      foo:foo\n  }\n  dofoo(obj.foo)//undefined\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("把函数传入语言内置的函数而不是传入你自己的函数")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n    //undefined\n    console.log(this.a)\n}\nvar obj={\n    a:1,\n    foo:foo\n}\nsetTimeout(obj.foo,1000)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("p",[s._v("回调函数丢失 this 绑定是非常常见的")]),s._v(" "),n("h3",{attrs:{id:"绑定规则-显示绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则-显示绑定"}},[s._v("#")]),s._v(" 绑定规则---显示绑定")]),s._v(" "),n("p",[s._v("使用 call 和 apply ---\x3e它们的第一个参数是对象，它们会把这个对象绑定到 this 上----\x3e称之为显示绑定,上代码")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n     console.log(this)\n }\n // var obj={a:1}\n foo.call(obj)\n 通过foo.call,调用foo-----\x3e强制把foo的this--》绑定到----》obj\n \n 你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者new Number(..)）。这通常被称为“装箱”\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("h4",{attrs:{id:"硬绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#硬绑定"}},[s._v("#")]),s._v(" 硬绑定")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo() {\n    console.log(this.a)\n}\nvar obj={\n    a:12,\n    foo:foo\n}\nvar bar = function () {\n    foo.call(obj)\n}\n   setTimeout(bar,1000)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("硬绑定典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值，上代码")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo(dosomething) {\n    console.log(this.a , dosomething)\n    return this.a + dosomething\n}\nvar obj = {\n    a:121\n}\nvar bar =function () {\n    return foo.apply(obj,arguments)\n}\nvar b= bar(3)\nconsole.log(b)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("p",[s._v("另一种方法,创建一个 i 重复使用的辅助函数")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function bind(fn,obj) {\n   return function () {\n       return fn.apply(obj,arguments)\n   }\n}\nvar obj = {\n    a:121\n}\nvar bar = bind( foo, obj );\nvar b = bar( 3 );\nconsole.log( b );\nbind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("h4",{attrs:{id:"api-调用的-上下文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-调用的-上下文"}},[s._v("#")]),s._v(" API 调用的‘上下文’")]),s._v(" "),n("p",[s._v("第三方库的许多函数，以及 js 语言和宿主环境中许多新的内置函数都提供了可选参数，通常被称为‘上下文’，其作用和 bind 一样")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v('// function foo(el) {\n//     console.log( el, this.id );\n// }\n// var obj = {\n//     id: "awesome"\n// };\n// // 调用 foo(..) 时把 this 绑定到 obj\n// [1, 2, 3].forEach( foo, obj );\n// // 1 awesome 2 awesome 3 awesome\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("h3",{attrs:{id:"绑定规则-》new-绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则-》new-绑定"}},[s._v("#")]),s._v(" 绑定规则----》new 绑定")]),s._v(" "),n("p",[s._v("使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。")]),s._v(" "),n("ol",[n("li",[s._v("创建（或者说构造）一个全新的对象。")]),s._v(" "),n("li",[s._v("这个新对象会被执行 [[ 原型 ]] 连接。")]),s._v(" "),n("li",[s._v("这个新对象会绑定到函数调用的 this。")]),s._v(" "),n("li",[s._v("如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象")])]),s._v(" "),n("h3",{attrs:{id:"被忽略的-this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#被忽略的-this"}},[s._v("#")]),s._v(" 被忽略的 this")]),s._v(" "),n("p",[s._v("把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 、bind，这些值会被忽略，实际用的是默认的绑定规则，直接上代码：")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function bar() {\n\t console.log(this.a)\n }\n var a = 2;\n /!*bar.call(undefined)//2*!/\n bar.apply(null)//2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("一种非常常见的做法是使用 apply(...),来展开一个数组并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数）")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("function foo(a,b) {\n\t\tconsole.log('a:'+a+',b:'+b )//a:1,b:2\n    }\n// foo.apply(null,[1,2])\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("柯粒化")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("var bar=foo.bind(null,1);\n\t\tbar(2)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("更安全的 this 传入特殊的对象，把 this 绑定到这个对象不会对程序产生任何副作用")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("var obj1 = Object.create(null);\nvar obj2 = {}\n\tconsole.log(obj1)\n\tconsole.log(obj2)\n\tobj1比obj2更空\nvar ø =  Object.create(null);\n  function foo(a,b) {\n      console.log('a:'+a+',b:'+b )\n  }\n  // foo.apply(null,[1,2])\n  //柯粒化\n  var bar=foo.bind(ø,2);\n  bar(3)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h3",{attrs:{id:"this-软绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-软绑定"}},[s._v("#")]),s._v(" this----\x3e软绑定")]),s._v(" "),n("p",[s._v("问题：硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this")]),s._v(" "),n("p",[s._v("解决方法：默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("if(!Function.prototype.softBind){\n    Function.prototype.softBind=function(obj){\n        var fn=this;\n        var args=Array.prototype.slice.call(arguments,1);\n        var bound=function(){\n            return fn.apply(\n                (!this||this===(window||global))?obj:this,\n                args.concat.apply(args,arguments)\n            );\n        };\n        bound.prototype=Object.create(fn.prototype);\n        return bound;\n    };\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[s._v("效果")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v('function foo(){\n    console.log("name: "+this.name);\n}\n\nvar obj1={name:"obj1"},\n    obj2={name:"obj2"},\n    obj3={name:"obj3"};\n\nvar fooOBJ=foo.softBind(obj1);\nfooOBJ();//"name: obj1" 在这里软绑定生效了，成功修改了this的指向，将this绑定到了obj1上\n\nobj2.foo=foo.softBind(obj1);\nobj2.foo();//"name: obj2" 在这里软绑定的this指向成功被隐式绑定修改了，绑定到了obj2上\n\nfooOBJ.call(obj3);//"name: obj3" 在这里软绑定的this指向成功被硬绑定修改了，绑定到了obj3上\n\nsetTimeout(obj2.foo,1000);//"name: obj1"\n/*回调函数相当于一个隐式的传参，如果没有软绑定的话，这里将会应用默认绑定将this绑定到全局环\n境上，但有软绑定，这里this还是指向obj1*/\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("p",[s._v("实现效果")]),s._v(" "),n("p",[s._v("在第一行，先通过判断，如果函数的原型上没有 softBind()这个方法，则添加它，然后通过 Array.prototype.slice.call(arguments,1)获取传入的外部参数，这里这样做其实为了函数柯里化，也就是说，允许在软绑定的时候，事先设置好一些参数，在调用函数的时候再传入另一些参数（关于函数柯里化大家可以去网上搜一下详细的讲解）最后返回一个 bound 函数形成一个闭包，这时候，在函数调用 softBind()之后，得到的就是 bound 函数，例如上面的 var fooOBJ=foo.softBind(obj1)。")]),s._v(" "),n("p",[s._v("在 bound 函数中，首先会判断调用软绑定之后的函数（如 fooOBJ）的调用位置，或者说它的 this 的指向，如果!this（this 指向 undefined）或者 this===(window||global)（this 指向全局对象），那么就将函数的 this 绑定到传入 softBind 中的参数 obj 上。如果此时 this 不指向 undefind 或者全局对象，那么就将 this 绑定到现在正在指向的函数（即隐式绑定或显式绑定）。fn.apply 的第二个参数则是运行 foo 所需要的参数，由上面的 args（外部参数）和内部的 arguments（内部参数）连接成，也就是上面说的柯里化。\n其实在第一遍看这个函数时，也有点迷，有一些疑问，比如 var fn=this 这句，在 foo 通过 foo.softBind()调用 softBind 的时候，fn 到底指向谁呢？是指向 foo 还是指向 softBind？我们可以写个 demo 测试，然后可以很清晰地看出 fn 指向什么：")]),s._v(" "),n("div",{staticClass:"language-plain line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[s._v("var a=2;\nfunction foo(){\n}\nfoo.a=3;\nFunction.prototype.softBind=function(){\n    var fn=this;\n    return function(){\n        console.log(fn.a);\n    }\n};\nFunction.prototype.a=4;\nFunction.prototype.softBind.a=5;\n\nfoo.softBind()();//3\nFunction.prototype.softBind()();//4\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("p",[s._v("可以看出，fn（或者说 this）的指向还是遵循 this 的绑定规则的，softBind 函数定义在 Function 的原型 Function.prototype 中，但是 JavaScript 中函数永远不会“属于”某个对象（不像其他语言如 java 中类里面定义的方法那样），只是对象内部引用了这个函数，所以在通过下面两种方式调用时，fn（或者说 this）分别隐式绑定到了 foo 和 Function.prototype，所以分别输出 3 和 4。后面的 fn.apply()也就相当于 foo.apply()。")])])}),[],!1,null,null,null);n.default=e.exports}}]);
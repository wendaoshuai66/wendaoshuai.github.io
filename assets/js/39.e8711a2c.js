(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{244:function(t,a,v){"use strict";v.r(a);var _=v(0),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"前端性能优化必备服务器知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化必备服务器知识"}},[t._v("#")]),t._v(" 前端性能优化必备服务器知识")]),t._v(" "),v("h2",{attrs:{id:"浏览器渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://www.w3.org/TR/navigation-timing/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.w3.org/TR/navigation-timing/"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/forgethttp.png",alt:"1"}})]),t._v(" "),v("p",[t._v("地址栏中输入 url，敲回车--》浏览器解决网络问题，是否能够出外网（测试从内网跨越到外网去，这个障碍可能是路由器、网关等等）----》解析域名，输入的网址是一段字符串，计算机不识别，必须通过 DNS 服务器做一下 DNS 域名解析。(DNS 就是一个大型数据库，在这个数据库中就维护着域名和 ip 地址的映射关系)，返回 ip 地址，计算机就能够识别服务器在什么地方---》TCP 连接之后把数据发过去，发到服务器上---〉到了服务器上，服务器入口就是一个 IP，IP 后面有好多服务器，好多服务器会共用一个 IP（怎么做到这一点，会用到反向代理）----》通过反向代理，服务器进行请求。----〉通过 TCP 响应响应就会渲染，那么就会进入该主题")]),t._v(" "),v("p",[t._v("缓存层：promptfor unload、redirect、Appcache")]),t._v(" "),v("p",[t._v("网络层：DNS、TCP、Request、Response")]),t._v(" "),v("p",[t._v("渲染层：Processing、onload")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/rander.png",alt:"2"}})]),t._v(" "),v("p",[t._v("unload 是指卸载掉了上一个页面，与重定向是并发的。")]),t._v(" "),v("p",[t._v("redirect 在浏览器缓存中寻找，缓存以索引形式存在。找到页面是否下载过，并且判断文件是否支持脱机浏览。(很早之前浏览器支持脱机浏览)前提文件没有过期")]),t._v(" "),v("p",[t._v("DNS 部分的优化使用 CDN")]),t._v(" "),v("p",[t._v("Http 是基于 Tcp 和 Udp，Tcp 是 IO 传输,每次请求都要握手挥手，所以可以优化，复用连接。")]),t._v(" "),v("p",[t._v("TCP 部分优化由底层程序员处理 HTTP1、2、3 长连接")]),t._v(" "),v("p",[t._v("TCP secureConnection 安全连接时间 https 基于 SSL 连接所以时间比较长")]),t._v(" "),v("p",[t._v("Requset->Resopnse 之前考虑服务器的性能数据质量等等")]),t._v(" "),v("p",[t._v("Resoponse 部分就是压缩 文件类型(text img 等速度是不一样的)和压缩之前的权衡")]),t._v(" "),v("p",[t._v("Processing domloading 先把 dom 加载都内存里 domInteractive 生成 dom 节点 domcontentloaded 内容加载 domcomplete 完毕")]),t._v(" "),v("p",[t._v("navigationStart")]),t._v(" "),v("p",[t._v("加载起始时间")]),t._v(" "),v("p",[t._v("redirectStart")]),t._v(" "),v("p",[t._v("重定向开始时间（如果发生了 HTTP 重定向，每次重定向都和当前文档同域的话，就返回开始重定向的 fetchStart 的值。其他情况，则返回 0）")]),t._v(" "),v("p",[t._v("redirectEnd")]),t._v(" "),v("p",[t._v("重定向结束时间（如果发生了 HTTP 重定向，每次重定向都和当前文档同域的话，就返回最后一次重定向接受完数据的时间。其他情况则返回 0）")]),t._v(" "),v("p",[t._v("fetchStart")]),t._v(" "),v("p",[t._v("浏览器发起资源请求时，如果有缓存，则返回读取缓存的开始时间")]),t._v(" "),v("p",[t._v("domainLookupStart")]),t._v(" "),v("p",[t._v("查询 DNS 的开始时间。如果请求没有发起 DNS 请求，如 keep-alive，缓存等，则返回 fetchStart")]),t._v(" "),v("p",[t._v("domainLookupEnd")]),t._v(" "),v("p",[t._v("查询 DNS 的结束时间。如果没有发起 DNS 请求，同上")]),t._v(" "),v("p",[t._v("connectStart")]),t._v(" "),v("p",[t._v("开始建立 TCP 请求的时间。如果请求是 keep-alive，缓存等，则返回 domainLookupEnd\n(secureConnectionStart)")]),t._v(" "),v("p",[t._v("如果在进行 TLS 或 SSL，则返回握手时间")]),t._v(" "),v("p",[t._v("connectEnd")]),t._v(" "),v("p",[t._v("完成 TCP 链接的时间。如果是 keep-alive，缓存等，同 connectStart")]),t._v(" "),v("p",[t._v("requestStart")]),t._v(" "),v("p",[t._v("发起请求的时间")]),t._v(" "),v("p",[t._v("responseStart")]),t._v(" "),v("p",[t._v("服务器开始响应的时间")]),t._v(" "),v("p",[t._v("domLoading")]),t._v(" "),v("p",[t._v("从图中看是开始渲染 dom 的时间，具体未知")]),t._v(" "),v("p",[t._v("domInteractive,加载内嵌的资源，例如图片...")]),t._v(" "),v("p",[t._v("未知")]),t._v(" "),v("p",[t._v("domContentLoadedEventStart")]),t._v(" "),v("p",[t._v("开始触发 DomContentLoadedEvent 事件的时间")]),t._v(" "),v("p",[t._v("domContentLoadedEventEnd 时间节点")]),t._v(" "),v("p",[t._v("DomContentLoadedEvent 事件结束的时间")]),t._v(" "),v("p",[t._v("domComplete")]),t._v(" "),v("p",[t._v("从图中看是 dom 渲染完成时间，具体未知")]),t._v(" "),v("p",[t._v("loadEventStart")]),t._v(" "),v("p",[t._v("触发 load 的时间，如没有则返回 0")]),t._v(" "),v("p",[t._v("loadEventEnd")]),t._v(" "),v("p",[t._v("load 事件执行完的时间，如没有则返回 0")]),t._v(" "),v("p",[t._v("unloadEventStart")]),t._v(" "),v("p",[t._v("unload 事件触发的时间")]),t._v(" "),v("p",[t._v("unloadEventEnd")]),t._v(" "),v("p",[t._v("unload 事件执行完的时间")]),t._v(" "),v("h3",{attrs:{id:"简单用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单用法"}},[t._v("#")]),t._v(" 简单用法")]),t._v(" "),v("p",[t._v("DNS 解析时间： domainLookupEnd - domainLookupStart")]),t._v(" "),v("p",[t._v("TCP 建立连接时间： connectEnd - connectStart")]),t._v(" "),v("p",[t._v("白屏时间： responseStart - navigationStart")]),t._v(" "),v("p",[t._v("dom 渲染完成时间： domContentLoadedEventEnd - navigationStart")]),t._v(" "),v("p",[t._v("页面 onload 时间： loadEventEnd - navigationStar")]),t._v(" "),v("div",{staticClass:"language-plain line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("let timing = performance.timing,\n    start = timing.navigationStart,\n    dnsTime = 0,4\n    tcpTime = 0,\n    firstPaintTime = 0,\n    domRenderTime = 0,\n    loadTime = 0;\n\ndnsTime = timing.domainLookupEnd - timing.domainLookupStart;\ntcpTime = timing.connectEnd - timing.connectStart;\nfirstPaintTime = timing.responseStart - start;\ndomRenderTime = timing.domContentLoadedEventEnd - start;\nloadTime = timing.loadEventEnd - start;\n\nconsole.log('DNS解析时间:', dnsTime , '\\nTCP建立时间:', tcpTime, '\\n首屏时间:', firstPaintTime,\n '\\ndom渲染完成时间:', domRenderTime, '\\n页面onload时间:', loadTime);\n \n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br"),v("span",{staticClass:"line-number"},[t._v("14")]),v("br"),v("span",{staticClass:"line-number"},[t._v("15")]),v("br"),v("span",{staticClass:"line-number"},[t._v("16")]),v("br"),v("span",{staticClass:"line-number"},[t._v("17")]),v("br")])]),v("h2",{attrs:{id:"dns-域名解析原理及-cdn-内容网络分发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-域名解析原理及-cdn-内容网络分发"}},[t._v("#")]),t._v(" DNS 域名解析原理及 CDN(内容网络分发)")]),t._v(" "),v("h3",{attrs:{id:"dns"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[t._v("#")]),t._v(" DNS")]),t._v(" "),v("p",[t._v("DNS(Domain Name System),域名解析，用于将域名转换成 IP")]),t._v(" "),v("h3",{attrs:{id:"为什么要进行域名解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行域名解析"}},[t._v("#")]),t._v(" 为什么要进行域名解析")]),t._v(" "),v("p",[t._v("一般我们在访问一个网站的时候，我们在地址栏里面输入的是域名，很少有人去输入 IP 来访问。比如说 blog.ctomorrow.top，当我们把这段域名输入到地址栏中后，因为域名是字符串，浏览器是无法解析字符串的，所以要把域名解析成 IP 地址才可以进行访问")]),t._v(" "),v("h3",{attrs:{id:"如何配置域名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何配置域名"}},[t._v("#")]),t._v(" 如何配置域名")]),t._v(" "),v("p",[t._v("当我们在买了云服务器和域名之后，要向让域名与服务器对应必须要进行相关的配置，通常配置面板就会提供商那里。")]),t._v(" "),v("p",[t._v("例如阿里云，在阿里云的域名控制台中就可以看到解析")]),t._v(" "),v("p",[t._v("在这里就可以配置服务")]),t._v(" "),v("p",[t._v("域名资源记录有很多中，分别代表者不同的类型。")]),t._v(" "),v("h3",{attrs:{id:"dns-域名解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-域名解析"}},[t._v("#")]),t._v(" DNS 域名解析")]),t._v(" "),v("p",[t._v("DNS 服务器内部是有一个大数据库的，主要的字段就两列，相当于 key-value 结构。key 是域名，value 是 IP。在进行域名解析的时候，把域名投到 DNS 服务器，然后 DNS 根据域名找到对应的 IP。")]),t._v(" "),v("p",[t._v("DNS 采用迭代查询的方式进行域名解析。首先看下图。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/dns.png",alt:"2"}})]),t._v(" "),v("p",[t._v("先来解释一下图上的几台主机。")]),t._v(" "),v("p",[t._v("1 号电脑就是我们的客户端，输入 url。")]),t._v(" "),v("p",[t._v("2 号主机就是 DNS 服务器。")]),t._v(" "),v("p",[t._v("3 号主机是 DNS 根服务器，存放顶级域名后缀与相应 TLD 服务器的 IP，用于映射顶级域名后缀的 TLD 服务器的 IP。")]),t._v(" "),v("p",[t._v("4 好主机是 DNS TLD 服务器，存放顶级域名与相应 Name 服务器的 IP，用于映射顶级域名的 Name 服务器的 IP。")]),t._v(" "),v("p",[t._v("5 号主机是 DNS Name 服务器，真正存放 IP 与域名的映射关系在这里，用于映射客户端所访问域名的 IP。")]),t._v(" "),v("h3",{attrs:{id:"cdn-内容分发网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn-内容分发网络"}},[t._v("#")]),t._v(" CDN(内容分发网络)")]),t._v(" "),v("p",[t._v("CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。（CDN 网络是在用户和服务器之间增加 Cache 层，如何将用户的请求引导到 Cache 上获得源服务器的数据，主要是通过接管 DNS 实现）")]),t._v(" "),v("h5",{attrs:{id:"cdn-是基于-dns-域名解析在网络上的一种优化策略。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn-是基于-dns-域名解析在网络上的一种优化策略。"}},[t._v("#")]),t._v(" CDN 是基于 DNS 域名解析在网络上的一种优化策略。")]),t._v(" "),v("h4",{attrs:{id:"曾经的集中式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#曾经的集中式"}},[t._v("#")]),t._v(" 曾经的集中式")]),t._v(" "),v("p",[t._v("在很久以前上网的时候，网站服务器只有一个，客户端很多，每次请求都要走很长很长的网络，访问网站效率很慢。")]),t._v(" "),v("h3",{attrs:{id:"分布式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式"}},[t._v("#")]),t._v(" 分布式")]),t._v(" "),v("p",[t._v("分布式的出现就是为了解决在访问网站的时候走很长网络的问题。在全球各地都放服务器，在请求的时候判断客户端的地理位置，找到离客户端最近的那台服务器，把请求资源返回给客户端。")]),t._v(" "),v("h3",{attrs:{id:"cdn-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cdn-原理"}},[t._v("#")]),t._v(" CDN 原理")]),t._v(" "),v("p",[t._v("当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。")]),t._v(" "),v("p",[t._v("CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备（边缘节点），告诉用户向这台设备发起请求。均衡设备把服务器的 IP 地址返回给用户。")]),t._v(" "),v("p",[t._v("用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务（多级缓存）器请求内容，直至追溯到网站的源服务器将内容拉到本地（回源）。")]),t._v(" "),v("h2",{attrs:{id:"tcp-协议及三次握手、四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议及三次握手、四次挥手"}},[t._v("#")]),t._v(" TCP 协议及三次握手、四次挥手")]),t._v(" "),v("h3",{attrs:{id:"网络协议模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络协议模型"}},[t._v("#")]),t._v(" 网络协议模型")]),t._v(" "),v("p",[t._v("网络中的网络协议模型共有两种：一种是网络标准 OSI/ISO 七层协议模型，一种是使用广泛 TCP/IP 五层协议模型。其实这两种都差不多，TCP/IP 五层协议模型是把 OSI/IOS 七层模型的上三层合并成为了应用层。")]),t._v(" "),v("h3",{attrs:{id:"数据在网络上的传输过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据在网络上的传输过程"}},[t._v("#")]),t._v(" 数据在网络上的传输过程")]),t._v(" "),v("p",[t._v("在网络传输上共有两个角色：客户端和服务端。客户端发送请求，服务端响应请求。网络请求在网络协议模型上是一个拆包和封包的过程。")]),t._v(" "),v("p",[t._v("过程如下：")]),t._v(" "),v("p",[t._v("数据发送端每经过一层都会封装上这层协议的协议头部向下传输。例如：对于网络请求来说，在应用层封装上 HTTP 的头部转换成报文，在传输层封装上 TCP 头部转换成数据包，在网络层封装上 IP 的头部转化成 IP 数据报，在数据链路层加上 MAC 地址封装成帧，然后在物理层转换成比特流进行传输。")]),t._v(" "),v("p",[t._v("在物理层传输过程中如果遇到交换机和路由器。遇到交换机把比特流转换成帧，根据交换机所指 MAC 地址重新封装成帧再向下转换进行传输；遇到路由器拆包到网络层，根据路由策略决定向下传的 IP 地址再进行向下封装传输。")]),t._v(" "),v("p",[t._v("经过万里长征终于到达服务器，会在网络协议模型中把第一步骤一一拆解开，最终拿到数据。响应过程中还是这么一套过程。")]),t._v(" "),v("h3",{attrs:{id:"数据通信的三种基本方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据通信的三种基本方式"}},[t._v("#")]),t._v(" 数据通信的三种基本方式")]),t._v(" "),v("p",[t._v("单向通信")]),t._v(" "),v("p",[t._v("单向通信又称单工通信，即只能有一个方向的通信而没有反方向的交互。比如：无线电广播、电视广播这种。")]),t._v(" "),v("p",[t._v("双向交替通信")]),t._v(" "),v("p",[t._v("双向交替通信又称半双工通信，即通信的双方都可以发送信息，但不能同时发送(当然也不能同时接收)。这种通信方式是一方发送另一方只能接受，等发送的一方不发了，接收的一方才可以发送。比如：对讲机等。")]),t._v(" "),v("p",[t._v("双向同时通信")]),t._v(" "),v("p",[t._v("双向同时通信又称全双工通信，即通信的双方都可以同时发送和接受信息。显然，双向通信的传输效率最高。TCP 就是全双工通信。")]),t._v(" "),v("h3",{attrs:{id:"tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),v("h4",{attrs:{id:"tcp-协议的特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议的特点"}},[t._v("#")]),t._v(" TCP 协议的特点")]),t._v(" "),v("p",[t._v("TCP 是面向连接的传输层协议")]),t._v(" "),v("p",[t._v("每一条 TCP 协议只能有两个端口")]),t._v(" "),v("p",[t._v("TCP 提供数据的可靠交付服务")]),t._v(" "),v("p",[t._v("TCP 是全双工通信")]),t._v(" "),v("p",[t._v("面向字节流")]),t._v(" "),v("h4",{attrs:{id:"tcp-头部"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-头部"}},[t._v("#")]),t._v(" TCP 头部")]),t._v(" "),v("p",[t._v("TCP 头部至少 20 字节的数据，如下图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/tcphead.png",alt:"2"}})]),t._v(" "),v("p",[t._v("0-4：我们都知道 TCP 协议是保证端到端可靠传输，首先是 4 个字节的目的端口和源端口")]),t._v(" "),v("p",[t._v("4-8：Sequence Number （发包的顺序号）")]),t._v(" "),v("p",[t._v("8-12：Acknowledgment Number （应答号,不同的应答号代表者不同的指令，标记此次动作）")]),t._v(" "),v("p",[t._v("12-16：标记位，偏移量，时间窗口等等")]),t._v(" "),v("p",[t._v("16-20：Checksum(校验码)、Urgent Pointer(偏移指针)")]),t._v(" "),v("p",[t._v("TCP Options TCP 内置的命令（FIN,SYN 就在这里）。")]),t._v(" "),v("p",[t._v("上层数据")]),t._v(" "),v("h4",{attrs:{id:"socket-套接字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket-套接字"}},[t._v("#")]),t._v(" socket 套接字")]),t._v(" "),v("p",[t._v("上面说到 TCP 的特点的时候说道每一条 TCP 只能有两个端口，这端口不是别的，就是套接字端口。")]),t._v(" "),v("p",[t._v("套接字接口的格式：")]),t._v(" "),v("div",{staticClass:"language-plain line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("socket = {IP地址 : 端口号}\n\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("h4",{attrs:{id:"三次握手、四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手、四次挥手"}},[t._v("#")]),t._v(" 三次握手、四次挥手")]),t._v(" "),v("p",[t._v("为什么三次握手、四次挥手？")]),t._v(" "),v("p",[t._v("TCP 保证的是应用程序之间端到端的可靠传输。要想可靠就必须要有这个机制。")]),t._v(" "),v("p",[t._v("三次握手")]),t._v(" "),v("p",[t._v("三次握手总结如下：")]),t._v(" "),v("p",[t._v("客户端对服务端说：Hi，你能收到我发的信息吗？")]),t._v(" "),v("p",[t._v("服务器对客户端说：我能收到，你能收到我发的吗？")]),t._v(" "),v("p",[t._v("客户端对服务器说：我也能收到。")]),t._v(" "),v("p",[t._v("是不是非常好理解，再来个详细。")]),t._v(" "),v("p",[t._v("开始的时候客户端和服务器的 TCP 连接都处于 CLOSE 状态。当要连接的时候，客户端为主动打开，服务端为被动打开。")]),t._v(" "),v("p",[t._v("一开始服务端服务器进程首先创建传输控制模块 TCB(这其中保存了连接重要的信息),然后服务端就处于 LISTEN 状态。")]),t._v(" "),v("p",[t._v("客户端向服务器发送一个 SYN=1,seq=n(SYN=1,建立连接的标志，seq 为头部的序号位)的数据包，此时客户端进入 SYN_SENT 状态(连接请求已发送)。")]),t._v(" "),v("p",[t._v("服务端接收到客户端发来的请求时，会向客户端发送确认并且请求客户端建立连接(SYN=1、ACK=1、seq=k,ack=n+1)，此时服务端进入 SYN_RCVD 状态(连接请求收到)")]),t._v(" "),v("p",[t._v("客户端接收到服务器的确认后，并且还要向服务器发送确认，(ACK=1,seq=n+1,ack=k+1)，此时 TCP 建立连接，客户端状态变为 EXTABLISHED(已连接状态)")]),t._v(" "),v("p",[t._v("服务端接受到客户端的确认之后，同样也进入 EXTABLISHED(已连接状态)。三次握手完毕")]),t._v(" "),v("p",[t._v("四次挥手")]),t._v(" "),v("p",[t._v("在此次聊天过程中，突然双方起了争执。")]),t._v(" "),v("p",[t._v("四次挥手总结如下：")]),t._v(" "),v("p",[t._v("客户端对服务端说：我不想听你说话了，不和你聊了(此时客户端已经把手机扔一边了)。")]),t._v(" "),v("p",[t._v("服务端对客户端说：你不想听，我也要说(服务端直男癌犯了，服务端说啥客户端都看不到)。")]),t._v(" "),v("p",[t._v("服务端对客户端说：我也不想和你说话了，冷战吧。")]),t._v(" "),v("p",[t._v("客户端对服务端说：好，冷战就冷战，然后双方删了微信。")]),t._v(" "),v("p",[t._v("开始处于数据传输过程中，双方状态为 ESTABLISHED。")]),t._v(" "),v("p",[t._v("首先客户端向服务端发送 FIN=1，seq=x(FIN=1 是断开连接的标志)的数据包，进入 FIN_WAIT1 状态(终止等待 1)。")]),t._v(" "),v("p",[t._v("服务端接受到客户端的请求，因为服务端这边还要收场，所以先应答客户端，进入 CLOSE_WAIT 状态(关闭等待)。此时 TCP 通信就进入到了半关闭状态。")]),t._v(" "),v("p",[t._v("客户端接收到服务端返回的确定进入 FIN_WAIT2 状态(终止等待 2).")]),t._v(" "),v("p",[t._v("服务端处理好自己的事情之后，向客户端发送一个 FIN=1 的包，进入 LAST_ACK(最后确认)状态。")]),t._v(" "),v("p",[t._v("客户端接收到服务端发送的关闭连接的包，并返回个服务端确认。进入 TIME_WAIT(时间等待)状态，此时 TCP 连接还没有释放点，必须要经过时间等待计数器设置的时间之后(2MSL),才会进入 CLOSED(关闭)状态。\n服务端接受到客户端的确认之后，进入 CLOSED(关闭)状态。")]),t._v(" "),v("p",[t._v("客户端时间等待计数器结束之后进入 CLOSED(关闭)状态。TCP 连接释放。")]),t._v(" "),v("h2",{attrs:{id:"http-缓存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存策略"}},[t._v("#")]),t._v(" HTTP 缓存策略")]),t._v(" "),v("h3",{attrs:{id:"缓存的定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的定义"}},[t._v("#")]),t._v(" 缓存的定义")]),t._v(" "),v("p",[t._v("缓存就是数据交换的缓冲区（称作 Cache），这个概念最初是来自于内存和 CPU。当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。")]),t._v(" "),v("h3",{attrs:{id:"web-缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#web-缓存"}},[t._v("#")]),t._v(" Web 缓存")]),t._v(" "),v("p",[t._v("客户端和服务器之间是通过请求和响应来相互通信的。")]),t._v(" "),v("h5",{attrs:{id:"请求的本质就是从客户端向服务器发起请求，获取服务器资源-图片、文件、数据-返回给客户端。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求的本质就是从客户端向服务器发起请求，获取服务器资源-图片、文件、数据-返回给客户端。"}},[t._v("#")]),t._v(" 请求的本质就是从客户端向服务器发起请求，获取服务器资源(图片、文件、数据)返回给客户端。")]),t._v(" "),v("p",[t._v("Web 缓存就是保存从服务器响应的资源，当发起下一次请求请求同样的资源的时候，不需要再请求服务端，直接从缓存中得到")]),t._v(" "),v("h3",{attrs:{id:"缓存类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存类型"}},[t._v("#")]),t._v(" 缓存类型")]),t._v(" "),v("p",[t._v("HTTP 缓存分为强缓存和协商缓存，共有四种缓存类型")]),t._v(" "),v("p",[t._v("强缓存")]),t._v(" "),v("p",[t._v("浏览器第一次请求服务器时，服务器会将文件和缓存时间一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据的时候，客户端会根据文件的过期时间去判断文件是否过期，如果未过期就从缓存数据库中拿文件，如果过期，则重新从服务器上请求文件。")]),t._v(" "),v("p",[t._v("1.Cache-Control")]),t._v(" "),v("p",[t._v("Cache-Control 是优先级最高的强缓存，它有一下值：")]),t._v(" "),v("p",[t._v("Cache-Control: no-cache 必须先与代理服务器确认是否更改，然后在在决定使用缓存还是请求，类似于协商缓存（304）。可以用于不让浏览器自己缓存，我们自己来控制缓存，让文件更可控。")]),t._v(" "),v("p",[t._v("Cache-Control: no-store 才是真正的不缓存数据到本地。")]),t._v(" "),v("p",[t._v("Cache-Control: public 可以被所有用户缓存（多用户共享），包括终端和 CDN 等中间代理服务器。")]),t._v(" "),v("p",[t._v("Cache-Control: private 只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存")]),t._v(" "),v("p",[t._v("Cache-Control: must-revalidate 如果缓存内容失效，请求必须发送服务器进行验证。")]),t._v(" "),v("p",[t._v("Cache-Control: max-age=s\t设置缓存时间，缓存内容在 s 秒后失效，仅 HTTP1.1 可用")]),t._v(" "),v("h5",{attrs:{id:"第一次请求服务器，响应头会返回一个-max-age，表示文件的缓存过期时间。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一次请求服务器，响应头会返回一个-max-age，表示文件的缓存过期时间。"}},[t._v("#")]),t._v(" 第一次请求服务器，响应头会返回一个 max-age，表示文件的缓存过期时间。")]),t._v(" "),v("h5",{attrs:{id:"第二次请求-客户端会校验文件是否过期，如果文件未过期则直接使用本地缓存，返回返状态码-200-from-memory-cache-或-200-from-disk-cache-，如果过期则进行协商缓存。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二次请求-客户端会校验文件是否过期，如果文件未过期则直接使用本地缓存，返回返状态码-200-from-memory-cache-或-200-from-disk-cache-，如果过期则进行协商缓存。"}},[t._v("#")]),t._v(" 第二次请求 客户端会校验文件是否过期，如果文件未过期则直接使用本地缓存，返回返状态码 200(from memory cache)或 200(from disk cache)，如果过期则进行协商缓存。")]),t._v(" "),v("p",[t._v("2.Expires")]),t._v(" "),v("p",[t._v("Expires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回。正是因为又服务器返回，而服务器时间和本地时间不同，所以它有时候是不准的。")]),t._v(" "),v("h5",{attrs:{id:"浏览器第一次请求服务器，响应头里会返回一个-expires-的文件过期时间。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器第一次请求服务器，响应头里会返回一个-expires-的文件过期时间。"}},[t._v("#")]),t._v(" 浏览器第一次请求服务器，响应头里会返回一个 Expires 的文件过期时间。")]),t._v(" "),v("h5",{attrs:{id:"第二次请求服务器时，客户端使用本地时间和文件的过期时间相比对，如果未过期则直接使用本地缓存返回状态码-200-from-memory-cache-或-200-from-disk-cache-则进行协商缓存。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二次请求服务器时，客户端使用本地时间和文件的过期时间相比对，如果未过期则直接使用本地缓存返回状态码-200-from-memory-cache-或-200-from-disk-cache-则进行协商缓存。"}},[t._v("#")]),t._v(" 第二次请求服务器时，客户端使用本地时间和文件的过期时间相比对，如果未过期则直接使用本地缓存返回状态码 200(from memory cache)或 200(from disk cache)则进行协商缓存。")]),t._v(" "),v("p",[t._v("协商缓存")]),t._v(" "),v("p",[t._v("浏览器第一次请求服务器的时候，服务器会将缓存标识和资源一起响应给客户端，客户端将二者备份至缓存服务器。再次请求数据时，客户端将备份的缓存标识发给服务器，服务器根据缓存标识决定是从缓存拿数据还是从服务器上请求数据。如果判断成功，返回 304 状态码，通知客户端从缓存中拿数据；如果判断失败，则再次请求进行缓存。")]),t._v(" "),v("p",[t._v("3.Etag/If-None-Match")]),t._v(" "),v("p",[t._v("Etag 规则是通过文件的内容来判断该不该读缓存，服务器把文件读出来，通过某种方式为文件加上标识(一般是通过 MD5 进行 base64 加密得出 hash 值，把这个值设置在相应头里面)，客户端下一次请求通过 If-None-Mach 带过来，服务器再比对和当前文件内容加密得出的 hash 值是否相同，如果相同则说明文件内容没有发生变化，可以从缓存中获取，如果不相同则文件发生变化，重新请求。这种是最准确的方式，同样也是最耗时的。")]),t._v(" "),v("h5",{attrs:{id:"客户端第一次请求服务器，响应头中返回包含文件缓存标识的-etag-标签。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端第一次请求服务器，响应头中返回包含文件缓存标识的-etag-标签。"}},[t._v("#")]),t._v(" 客户端第一次请求服务器，响应头中返回包含文件缓存标识的 Etag 标签。")]),t._v(" "),v("h5",{attrs:{id:"客户端第二次请求服务器，请求头包含-if-none-match-服务器获得缓存标识后，用该标识和文件-hash-值进行比对。比对成功，则文件未过期，从缓存中拿返回状态码-304，比对失败，重新请求文件并缓存，返回状态码-200"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端第二次请求服务器，请求头包含-if-none-match-服务器获得缓存标识后，用该标识和文件-hash-值进行比对。比对成功，则文件未过期，从缓存中拿返回状态码-304，比对失败，重新请求文件并缓存，返回状态码-200"}},[t._v("#")]),t._v(" 客户端第二次请求服务器，请求头包含 IF-None-Match,服务器获得缓存标识后，用该标识和文件 hash 值进行比对。比对成功，则文件未过期，从缓存中拿返回状态码 304，比对失败，重新请求文件并缓存，返回状态码 200")]),t._v(" "),v("p",[t._v("4.Last-Modified/If-Modified-Since")]),t._v(" "),v("p",[t._v("Last-Modefied 规则是通过文件的最后修改时间来判断该不该读缓存，服务器端设置响应头 Last-Modified，表示最后修改时间。客户端再次请求服务器的时候通过请求头 If-Modified-Since 把最后修改时间提交给服务器，服务器判断客户端返回的时间和文件的时候相比对，如果相等则表示未过期，可以从缓存中拿，如果不相等则表示缓存已过期，再次请求并缓存。")]),t._v(" "),v("h5",{attrs:{id:"第一次请求服务器，响应头中返回-last-modified-头，表示文件最后修改时间。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一次请求服务器，响应头中返回-last-modified-头，表示文件最后修改时间。"}},[t._v("#")]),t._v(" 第一次请求服务器，响应头中返回 Last-Modified 头，表示文件最后修改时间。")]),t._v(" "),v("h5",{attrs:{id:"第二次请求服务器，请求头中返回-if-modified-since-头，把文件最后修改时间返回给服务器，服务器来做决策。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二次请求服务器，请求头中返回-if-modified-since-头，把文件最后修改时间返回给服务器，服务器来做决策。"}},[t._v("#")]),t._v(" 第二次请求服务器，请求头中返回 If-Modified-Since 头，把文件最后修改时间返回给服务器，服务器来做决策。")]),t._v(" "),v("h3",{attrs:{id:"什么样的文件可以缓存，什么样是文件不可以缓存？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么样的文件可以缓存，什么样是文件不可以缓存？"}},[t._v("#")]),t._v(" 什么样的文件可以缓存，什么样是文件不可以缓存？")]),t._v(" "),v("p",[t._v("静态资源可以缓存")]),t._v(" "),v("p",[t._v("动态资源不能缓存")]),t._v(" "),v("p",[t._v("需要根据 cookie 拿到信息不能缓存")]),t._v(" "),v("p",[t._v("post 请求不能缓存")]),t._v(" "),v("p",[t._v("HTTP 头中没有包含缓存策略标记的不能缓存")]),t._v(" "),v("h3",{attrs:{id:"缓存策略图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略图"}},[t._v("#")]),t._v(" 缓存策略图")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://wendaoshuai66.github.io/study/note/images/cctch.png",alt:"1"}})]),t._v(" "),v("h3",{attrs:{id:"nginx-服务器缓存实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nginx-服务器缓存实践"}},[t._v("#")]),t._v(" Nginx 服务器缓存实践")]),t._v(" "),v("p",[t._v("在 Web 缓存中我们一般用，Nginx 作为代理服务器做缓存。这样做比较简单一些。")]),t._v(" "),v("p",[t._v("Nginx 服务器是默认开启 Etag 规则的。可以通过一下几项配置浏览器缓存。")])])}),[],!1,null,null,null);a.default=e.exports}}]);
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript 使用手册 | 前端日志</title>
    <meta name="description" content="欢迎访问我的前端日志">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/hero.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.f48a6bab.css" as="style"><link rel="preload" href="/assets/js/app.ae0effdb.js" as="script"><link rel="preload" href="/assets/js/2.1f0a0a54.js" as="script"><link rel="preload" href="/assets/js/26.4adf545a.js" as="script"><link rel="prefetch" href="/assets/js/10.0bedbff4.js"><link rel="prefetch" href="/assets/js/11.8e798407.js"><link rel="prefetch" href="/assets/js/12.05d3ad52.js"><link rel="prefetch" href="/assets/js/13.fef0d11f.js"><link rel="prefetch" href="/assets/js/14.8220dd22.js"><link rel="prefetch" href="/assets/js/15.b9ff6bb1.js"><link rel="prefetch" href="/assets/js/16.812d4a9f.js"><link rel="prefetch" href="/assets/js/17.b19cab9e.js"><link rel="prefetch" href="/assets/js/18.18dc98f6.js"><link rel="prefetch" href="/assets/js/19.2dee6f08.js"><link rel="prefetch" href="/assets/js/20.ca97fb4a.js"><link rel="prefetch" href="/assets/js/21.3321d072.js"><link rel="prefetch" href="/assets/js/22.148c9e36.js"><link rel="prefetch" href="/assets/js/23.f75937fb.js"><link rel="prefetch" href="/assets/js/24.b47166a8.js"><link rel="prefetch" href="/assets/js/25.5e54128d.js"><link rel="prefetch" href="/assets/js/27.5360046e.js"><link rel="prefetch" href="/assets/js/28.894ad0fb.js"><link rel="prefetch" href="/assets/js/29.6d8f45f9.js"><link rel="prefetch" href="/assets/js/3.ec2aba29.js"><link rel="prefetch" href="/assets/js/30.0414a72d.js"><link rel="prefetch" href="/assets/js/31.7b9217a6.js"><link rel="prefetch" href="/assets/js/32.853bead4.js"><link rel="prefetch" href="/assets/js/33.df4ca218.js"><link rel="prefetch" href="/assets/js/34.346f1006.js"><link rel="prefetch" href="/assets/js/35.b2370c56.js"><link rel="prefetch" href="/assets/js/36.c0070f49.js"><link rel="prefetch" href="/assets/js/37.7d8dcb7a.js"><link rel="prefetch" href="/assets/js/38.c8c739fe.js"><link rel="prefetch" href="/assets/js/39.ad05e1ef.js"><link rel="prefetch" href="/assets/js/4.4379ec61.js"><link rel="prefetch" href="/assets/js/40.7318cad1.js"><link rel="prefetch" href="/assets/js/41.4632bdb1.js"><link rel="prefetch" href="/assets/js/42.e9e383b6.js"><link rel="prefetch" href="/assets/js/43.abff58ec.js"><link rel="prefetch" href="/assets/js/44.e9f9176b.js"><link rel="prefetch" href="/assets/js/45.20b1abd2.js"><link rel="prefetch" href="/assets/js/46.ef2c8c7f.js"><link rel="prefetch" href="/assets/js/47.b7479d5c.js"><link rel="prefetch" href="/assets/js/48.624ddde4.js"><link rel="prefetch" href="/assets/js/49.a60ab866.js"><link rel="prefetch" href="/assets/js/5.c37a0a9f.js"><link rel="prefetch" href="/assets/js/50.6f312b15.js"><link rel="prefetch" href="/assets/js/51.2f38cf09.js"><link rel="prefetch" href="/assets/js/52.334a821c.js"><link rel="prefetch" href="/assets/js/53.3ba37eb0.js"><link rel="prefetch" href="/assets/js/54.b4205324.js"><link rel="prefetch" href="/assets/js/55.62119911.js"><link rel="prefetch" href="/assets/js/56.33f10cd7.js"><link rel="prefetch" href="/assets/js/57.fea490f5.js"><link rel="prefetch" href="/assets/js/58.862f519b.js"><link rel="prefetch" href="/assets/js/6.f05ab208.js"><link rel="prefetch" href="/assets/js/7.1e3b443b.js"><link rel="prefetch" href="/assets/js/8.ff536b22.js"><link rel="prefetch" href="/assets/js/9.9129683e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f48a6bab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div> <a href="https://github.com/wendaoshuai66/blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div> <a href="https://github.com/wendaoshuai66/blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/unknowHtml1.html" class="sidebar-link">你不知道的 HTML</a></li><li><a href="/blog/cssnote.html" class="sidebar-link">CSS 简介及实用技巧</a></li><li><a href="/blog/3d.html" class="sidebar-link">CSS3 构造 3D 世界</a></li><li><a href="/blog/jsFunctionalProgramming_bottom.html" class="sidebar-link">JavaScript 函数式编程--下</a></li><li><a href="/blog/jsFunctionalProgramming.html" class="sidebar-link">JavaScript 函数式编程--上</a></li><li><a href="/blog/前端中经常出现的错误及捕获.html" class="sidebar-link">前端中经常出现的错误及捕获</a></li><li><a href="/blog/深拷贝.html" class="sidebar-link">对深拷贝的研究</a></li><li><a href="/blog/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/blog/php_up.html" class="sidebar-link">PHP 与 MySQL 开发入门上</a></li><li><a href="/blog/php_middle.html" class="sidebar-link">Php 与 MySql 开发入门中</a></li><li><a href="/blog/php_down.html" class="sidebar-link">Php 与 MySql 开发入门下</a></li><li><a href="/blog/ES5_top.html" class="sidebar-link">ECMAScript5.1 新增语法上</a></li><li><a href="/blog/ES5_bottom.html" class="sidebar-link">ECMAScript5.1 新增语法下</a></li><li><a href="/blog/ES5_core.html" class="sidebar-link">ES5 的核心技术</a></li><li><a href="/blog/ES5_core1.html" class="sidebar-link">不知道的 JavaScript</a></li><li><a href="/blog/JavaScript执行堆栈探索.html" class="sidebar-link">JavaScript 执行堆栈探索</a></li><li><a href="/blog/Interview.html" class="sidebar-link">面试题积累 1</a></li><li><a href="/blog/面向切面.html" class="sidebar-link">面向切面初探</a></li><li><a href="/blog/system.html" class="sidebar-link">初探 System.js</a></li><li><a href="/blog/前端架构与性能优化那些事.html" class="sidebar-link">前端架构与性能优化那些事</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue原理解析之准备工作.html" class="sidebar-link">vue 原理解析之准备工作</a></li><li><a href="/blog/vue原理解析之数据驱动.html" class="sidebar-link">vue 原理解析之数据驱动</a></li><li><a href="/blog/vue原理解析之编译深入.html" class="sidebar-link">vue 原理解析之编译深入</a></li><li><a href="/blog/vue原理解析之响应式原理深入.html" class="sidebar-link">vue 原理解析之响应式原理深入</a></li><li><a href="/blog/简单的实现Vue之响应式.html" class="sidebar-link">简单的实现 Vue 之响应式</a></li><li><a href="/blog/vue原理解析之nextTick探索.html" class="sidebar-link">vue 原理解析之 nextTick 探索</a></li><li><a href="/blog/Webpack.html" class="sidebar-link">常用的前端构建工具-Webpack</a></li><li><a href="/blog/Webpack使用总结.html" class="sidebar-link">Webpack 使用总结</a></li><li><a href="/blog/Webpack系列手写模块打包代码.html" class="sidebar-link">Webpack 系列手写模块打包代码</a></li><li><a href="/blog/React入门必学[上].html" class="sidebar-link">React 入门必学【上】</a></li><li><a href="/blog/React入门必学[下].html" class="sidebar-link">React 入门必学【下】</a></li><li><a href="/blog/Redux原理.html" class="sidebar-link">探索 Redux 原理</a></li><li><a href="/blog/TypeScript使用手册.html" class="active sidebar-link">TypeScript 使用手册</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#typescript-介绍" class="sidebar-link">TypeScript 介绍</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#使用-vscode-编写-typescript" class="sidebar-link">使用 VSCode 编写 TypeScript</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#ts-基础系列之-基本数据类型" class="sidebar-link">TS 基础系列之-基本数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#ts-基础系列之-函数" class="sidebar-link">TS 基础系列之-函数</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#ts-基础系列之-类" class="sidebar-link">TS 基础系列之-类</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#接口-2" class="sidebar-link">接口</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#mixins" class="sidebar-link">Mixins</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#泛型" class="sidebar-link">泛型</a></li><li class="sidebar-sub-header"><a href="/blog/TypeScript使用手册.html#module-模式和-namespace" class="sidebar-link">Module 模式和 namespace</a></li></ul></li><li><a href="/blog/NodeJS入门.html" class="sidebar-link">NodeJS 入门</a></li><li><a href="/blog/NodeJS框架入门.html" class="sidebar-link">NodeJs 框架入门</a></li><li><a href="/blog/NodeJS使用的总结.html" class="sidebar-link">NodeJS 使用的总结</a></li><li><a href="/blog/pm2项目部署总结.html" class="sidebar-link">pm2 项目部署总结</a></li><li><a href="/blog/KOA源码的阅读.html" class="sidebar-link">KOA 源码的阅读</a></li><li><a href="/blog/深入Koa原理.html" class="sidebar-link">深入 Koa 原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js_and_qa.html" class="sidebar-link">JavaScript 与 QA 测试工程师</a></li><li><a href="/blog/tegratedTesting.html" class="sidebar-link">JavaScript 集成化测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/为什么要使用package-lock.json.html" class="sidebar-link">为什么要使用 package-lock.json</a></li><li><a href="/blog/Package.json依赖管理.html" class="sidebar-link">Package.json 依赖管理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/http协议.html" class="sidebar-link">HTPP 协议那些事</a></li><li><a href="/blog/server-po.html" class="sidebar-link">前端性能优化必备服务器知识</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Linux.html" class="sidebar-link">Linux 基础入门</a></li><li><a href="/blog/Linux_supplement.html" class="sidebar-link">Linux 补充</a></li><li><a href="/blog/Linux_web.html" class="sidebar-link">Linux 中配置静态网络连接</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/前端中的数据结构-排序.html" class="sidebar-link">前端中的数据结构-排序</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="typescript-使用手册"><a href="#typescript-使用手册" class="header-anchor">#</a> TypeScript 使用手册</h1> <h2 id="typescript-介绍"><a href="#typescript-介绍" class="header-anchor">#</a> TypeScript 介绍</h2> <p>TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p> <h4 id="typescript-与-javascript-的比较"><a href="#typescript-与-javascript-的比较" class="header-anchor">#</a> TypeScript 与 JavaScript 的比较</h4> <p>TypeScript 与 JavaScript 相比进步的地方包括：加入注释，让编辑器理解所支持的对象和函数，编译器会移除注释，不会增加开销；增加一个完整的类结构，使之更新是传统的对象语言。最大的好处就是加入了类型检查，可以让我们书写代码的时候更加规范。</p> <h4 id="_5-分钟上手-typescript-摘抄于官网"><a href="#_5-分钟上手-typescript-摘抄于官网" class="header-anchor">#</a> 5 分钟上手 TypeScript <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" target="_blank" rel="noopener noreferrer">摘抄于官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>npm install -g typescript

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="构建你的第一个-typescript-文件"><a href="#构建你的第一个-typescript-文件" class="header-anchor">#</a> 构建你的第一个 TypeScript 文件</h5> <p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>function greeter(person) {
    return &quot;Hello, &quot; + person;
}

let user = &quot;Jane User&quot;;

document.body.innerHTML = greeter(user);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="编译代码"><a href="#编译代码" class="header-anchor">#</a> 编译代码</h5> <p>我们使用了.ts 扩展名，但是这段代码仅仅是 JavaScript 而已。 你可以直接从现有的 JavaScript 应用里复制/粘贴这段代码。</p> <p>在命令行上，运行 TypeScript 编译器：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>tsc greeter.ts
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>输出结果为一个 greeter.js 文件，它包含了和输入文件中相同的 JavsScript 代码。 一切准备就绪，我们可以运行这个使用 TypeScript 写的 JavaScript 应用了！</p> <p>接下来让我们看看 TypeScript 工具带来的高级功能。 给 person 函数的参数添加: string 类型注解，如下：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>function  greeter(person:string){
    return 'hello ' + person;
}
let usr = &quot;Jane User&quot;;
document.body.textContent = greeter(usr);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="类型注解"><a href="#类型注解" class="header-anchor">#</a> 类型注解</h4> <p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>function greeter(person: string) {
    return &quot;Hello, &quot; + person;
}

let user = [0, 1, 2];

document.body.innerHTML = greeter(user);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>重新编译，你会看到产生了一个错误。</p> <p><img src="https://wendaoshuai66.github.io/study/note/images/ts1.png" alt=""></p> <p>类似地，尝试删除 greeter 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript 提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p> <p>要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p> <h5 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h5> <p>让我们开发这个示例应用。这里我们使用接口来描述一个拥有 firstName 和 lastName 字段的对象。 在 TypeScript 里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>interface Person{
    firstName:string;
    lastName:string;
}
function greeter(person:Person){
    return &quot;hello&quot;+ person.firstName + person.lastName;
}
let user={firstName:'liu',lastName:'shuai'};

document.body.textContent = greeter(user)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="类"><a href="#类" class="header-anchor">#</a> 类</h5> <p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p> <p>让我们创建一个 Student 类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。</p> <p>还要注意的是，在构造函数的参数上使用 public 等同于创建了同名的成员变量。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//创建一个Student的类,它带有一个构造函数和一些公共字段
//在构造函数的参数上使用public等同于创建了同名的成员变量。

class Student{
    fullName :String;
    constructor(public firstName,public middleInitial,public lastName){
        this.fullName = firstName + &quot;&quot; +middleInitial+&quot;&quot;+lastName;
    }
}

interface Person{
    firstName;
    lastName;
}

function greeter(person:Person){
    return &quot;hello&quot; + person.firstName + person.lastName
}

const user = new Student('liushuai','m.','User')

document.body.textContent = greeter(user)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>重新运行 tsc greeter.ts，你会看到生成的 JavaScript 代码和原先的一样。 TypeScript 里的类只是 JavaScript 里常用的基于原型面向对象编程的简写。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//创建一个Student的类,它带有一个构造函数和一些公共字段
//在构造函数的参数上使用public等同于创建了同名的成员变量。
var Student = /** @class */ (function () {
    function Student(firstName, middleInitial, lastName) {
        this.firstName = firstName;
        this.middleInitial = middleInitial;
        this.lastName = lastName;
        this.fullName = firstName + &quot;&quot; + middleInitial + &quot;&quot; + lastName;
    }
    return Student;
}());
function greeter(person) {
    return &quot;hello&quot; + person.firstName + person.lastName;
}
var user = new Student('liushuai', 'm.', 'User');
document.body.textContent = greeter(user);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="使用-vscode-编写-typescript"><a href="#使用-vscode-编写-typescript" class="header-anchor">#</a> 使用 VSCode 编写 TypeScript</h2> <h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <p><a href="https://www.cnblogs.com/yasepix/p/9294491.html" target="_blank" rel="noopener noreferrer">VS Code 运行 TypeScript 操作指南(转)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/4f219f20af75" target="_blank" rel="noopener noreferrer">vscode 下搭建 Typescript 编译环境<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://segmentfault.com/a/1190000016305647" target="_blank" rel="noopener noreferrer">使用 vscode 写 typescript（node.js 环境）起手式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>VSCode 可以配置 TypeScript 的自动编译。</p> <p>1.全局安装 typescript</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>npm i -g typescript

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2.生成并配置 tsconfig.json</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>tsc --init
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>tsconfig.json 说明</p> <p>官网所有配置选项<a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>{//tsconfig.json文件内容
// 指定需要编译的目录
&quot;include&quot;: [&quot;src/**/*&quot;],
// 排除指定目录
&quot;exclude&quot;: [&quot;node_modules&quot;],
// 编译选项配置
&quot;compilerOptions&quot;: {
&quot;outDir&quot;: &quot;./output&quot;, // 输出目录
&quot;lib&quot;: [&quot;dom&quot;,&quot;es5&quot;,&quot;es2015&quot;], // 编译过程中需要引入的库文件的列表
&quot;module&quot;: &quot;commonjs&quot;, // 采用的模块系统
&quot;moduleResolution&quot;: &quot;node&quot;,
&quot;target&quot;: &quot;es5&quot;, // 编译输出目标 ES 版本
&quot;strict&quot;: true, // 以严格模式解析
&quot;sourceMap&quot;: true, // 是否包含可以用于 debug 的 sourceMap
&quot;emitDecoratorMetadata&quot;: true, // 启用设计类型元数据（用于反射）
&quot;experimentalDecorators&quot;: true, // 启用装饰器
&quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入
&quot;isolatedModules&quot;: false, // 将每个文件作为单独的模块
&quot;esModuleInterop&quot;: true, //导入语法 import foo from &quot;foo&quot;
//【最佳实践】true打开的话对应我们要用任何的Library都需要.d.ts即使是空定义，放心可以下载。
&quot;noImplicitAny&quot;: false, // 在表达式和声明上有隐含的any类型时报错
&quot;noImplicitReturns&quot;: true, // 不是函数的所有返回路径都有返回值时报错。
&quot;importHelpers&quot;: true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等
&quot;listFiles&quot;: true, // 编译过程中打印文件名
&quot;removeComments&quot;: true, // 移除注释
&quot;suppressImplicitAnyIndexErrors&quot;: true,
&quot;allowJs&quot;: true, // 允许编译javascript文件
&quot;pretty&quot;: true, // 给错误和消息设置样式，使用颜色和上下文

&quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块名的基准目录,相当于加了前缀
// 指定特殊模块的路径
&quot;paths&quot;: {
&quot;jquery&quot;: [
&quot;node_modules/jquery/dist/jquery&quot;
]
},

// 每当编译器在某一rootDirs的子目录下发现了相对模块导入，它就会尝试从每一个rootDirs中导入。
// 例如场景构建中的会将某些文件夹,输出拷贝到同一个目录下
&quot;rootDirs&quot;: [
&quot;src/views&quot;,
&quot;generated/templates/views&quot;
]

}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>3.监测文件改动并编译</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>tsc -w
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="ts-基础系列之-基本数据类型"><a href="#ts-基础系列之-基本数据类型" class="header-anchor">#</a> TS 基础系列之-基本数据类型</h2> <p>每种语言都会有属于自己的数据类型，ts 的基本数据类型基本上是继承了 js，但也在基础之上增加了几个不一样的类型</p> <p>1.布尔型 true／falses</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//在js中声明boolean型的方法和ts中的不同之处
let flag = true;
let flag: boolean = true;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>2.float,数值型（在 js 和 ts 中数字型都是 float）</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//在js中声明number型的方法和ts中的不同之处
let age = 26;
let age: number = 26;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>3.字符型 Strings</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//在js中声明number型的方法和ts中的不同之处
let name = 'boren';
let name: string = 'boren';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>4.数组 Array</p> <p>//在 js 中声明数组的方法和 ts 中的不同之处
//1.js 中声明数组的两种方式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let city = [];
let city = new Array();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>//2.ts 中声明数组的两种方式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let city: string[] = [];
let city:Array&lt;string&gt; = []
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>//在 ts 中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍</p> <p>5.元组 Tuple</p> <p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//可以定义数组中元素不相同的数据类型
let people = ['boren',26];//js
let people:[string,number];
people = ['boren',26];//ts
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>6.枚举 Enum</p> <p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：
let school = {

     teacherOne : 'Mars',
     teacherTwo:'yupeng',
     teacherThree:'luxuesong'

} 
console.log(school.teacherOne)//Mars

在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象
Object.getOwnPropertyDescriptor（school,‘teacherOne’）

// {
// value: Mars,
// writable: true,
// enumerable: true,
// configurable: true
// }

其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false
//ts中枚举类型的用法
enum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};
let teacher:classMember = classMember.luxuesong

我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>声明一个枚举类型</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>enum Color {Red,Green,Blue}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>编译成 es5 代码是</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>var Color;
(function (Color) {
    Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;
    Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;;
    Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;
})(Color || (Color = {}));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在声明的时候可以对索引进行赋值</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>enum Color {Red = 1,Green = 4,Blue};  //赋值操作：所赋值的值后面会按照赋值索引继续排列
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>获取枚举类型某个值的索引</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>var c : Color = Color.Blue    //获取Blue的索引
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>7.通用数据类型 Any</p> <p>当不知道变量的类型是什么的时候，就可以使用 any 类型</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>var notArr : Array&lt;any&gt; = [1,'12',false]
或

let list4:any[] = ['1',4,6,false]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>8.空值 Void</p> <p>在 js 中我们其实对 void 不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在 js 中常常出现的位置就是在 a 标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的 a 标签，有时候会调用一个简单的函数，仅此而已，那么我们就会</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;people()&quot;&gt;点我&lt;/a&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在 ts 中，void 类型像是与 any 类型相反，它表示没有任何类型。Void 是对函数进行声明的,定义函数的时候，函数是要有返回值类型的，写了返回值类型如果不返回特定类型的值，就会报错。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>function test1() : number{
    
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面代码会报错，因为返回值类型为 number，没有返回。</p> <p>使用 void 声明函数的返回值类型，表示不需要有返回值。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>
function test2() : void {
    
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>9.Never</p> <p>never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p> <p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p> <p>下面是一些返回 never 类型的函数：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>10.类型断言</p> <p>在 ts 中类型断言这种方式还是比较有用处的，其相当于 js 中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。</p> <p>两种写法</p> <p>其一是“尖括号”语法：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//类型断言第一种写法

let someValue :any = 'this is strings';

let strLength :number = (&lt;string&gt;someValue).length;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>另一个为 as 语法：</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>let someValue :any = 'this is strings';

let strLength :number = (someValue as string).length;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p> <p>###总结</p> <p>通过以上的介绍相信对 ts 的数据类型已经有了大概的了解，其实相对于 js,ts 的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts 的文件是 xxx.ts 但由于编译过后和 js 没有什么大的不同点，能够很好的运行在浏览器端，其中 class、public 等等函数及模块编译过后的 js 能后让你更深入的了解 js</p> <p>用 let 关键字来代替大家所熟悉的 JavaScript 关键字 var。 let 关键字是 JavaScript 的一个新概念，TypeScript 实现了它。 很多常见的问题都可以通过使用 let 来解决，所以尽可能地使用 let 来代替 var 吧。</p> <h2 id="ts-基础系列之-函数"><a href="#ts-基础系列之-函数" class="header-anchor">#</a> TS 基础系列之-函数</h2> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <p>函数是 JavaScript 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。 TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p> <p>1.函数的创建</p> <p>在 ts 中函数创建也氛围两种匿名函数和有命名的函数</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//函数的创建
//有名字的函数
function people(x){
    return x;
}

//匿名函数
let z=100;
const people1 =function(x){
    return x+z;
} 
const result  = people1(1)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>2.函数的参数类型和返回值类型</p> <p>⚠️只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正</p> <p>⚠️设定了类型之后必须要返回相对应的类型，否则会报错</p> <p>⚠️如果函数没有返回任何值，也必须指定返回值类型为 void 而不能留空</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//2.函数的参数类型和返回值类型

/**
 * @param {*} x number
 * @param {*} y number
 * return number
 */

 const add = (x:number,y:number):number=&gt;x+y

 const addResult  = add(1,1);

 //书写完整类型
const myadd :(baseValue:number,increment:number)=&gt;number =(x:number,y:number):number=&gt;x+y;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>3.函数的可选参数和默认参数</p> <p>⚠️传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错</p> <p>⚠️可选参数用?argname 表示，必须跟在必须参数后面</p> <p>⚠️没有传递参数或传递的值是 undefined，这种叫做默认初始化值的参数</p> <p>⚠️所有必须参数后面的带默认初始化的参数都是可选的，调用时可省略</p> <p>⚠️带默认值的参数如果出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值</p> <p>⚠️当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>
//1.参数个数必须与函数期望的参数个数一致，否则会报错

const myadd :(baseValue:number,increment:number)=&gt;number =(x:number,y:number):number=&gt;x+y;
myadd(1)//报错
myadd(1,2)
myadd(1,2,3)//报错


//2.可选参数用?argname表示，必须跟在必须参数后面

const buildName = (firstName:string,lastName?:string)=&gt;firstName+lastName

console.log(buildName('liu'))//liuundefined
console.log(buildName('liu','shuai'))//liushuai


//没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数

const buildName1 = (firstName:string,lastName?:string)=&gt;firstName+lastName

console.log(buildName1('liu'))//liuundefined
console.log(buildName1('liu',undefined))//liuundefined

//所有必须参数后面的带默认初始化的参数都是可选的，调用时可省略

const buildName2 = (firstName:string,lastName='shuai')=&gt;firstName+lastName

console.log(buildName2('liu'))//liushuai
console.log(buildName2('liu','shuai'))//liushuai

//带默认值的参数如果出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值

const buildName3 = (lastName='shuai',firstName:string)=&gt;firstName+lastName

console.log(buildName3('shuai','liu'))//liushuai
console.log(buildName3(undefined,'shuai'))//shuai shuai



//当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）

const buildName4 = (firstName:string,...otherName:string[]):string=&gt;firstName+otherName.join('')

console.log(buildName4('liu'))//liu
console.log(buildName4('shuai','age','24'))//shuaiage24

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>4.函数的重载</p> <p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>
// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型
const compute = (type: number, ...resetData: number[]):number | string =&gt; {
    if (type === 1 ) {
      return resetData.reduce((a:number, b:number):number =&gt; a + b);
    } else if (type === 2) {
      return String(resetData.reduce((a:number, b:number):number =&gt; a * b));
    }
  } 
  console.log(compute(1, 3, 4, 5, 6)) // 18
  console.log(compute(2, 3, 4, 5, 6)) // '360'
  
  // 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型
  
  const compute1 = (type: number, ...resetData: number[]):number;
  const compute2 = (type: number, ...resetData: number[]):string;
  const compute3= (type: number, ...resetData: number[]):number | string =&gt; {
    if (type === 1 ) {
      return resetData.reduce((a:number, b:number):number =&gt; a + b);
    } else if (type === 2) {
      return String(resetData.reduce((a:number, b:number):number =&gt; a * b));
    }
  } 
  console.log(compute3(1, 3, 4, 5, 6)) // 18
  console.log(compute3(2, 3, 4, 5, 6)) // '360'
  
  // 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>5.this 和箭头函数（Lambads）</p> <p>非常好的使用方式</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>let MathName = {
  person:['Mike','Joken','Amada'],
  getName:function(){
    return ()=&gt;{
      let index = Math.floor(Math.random()*3);
      return {
        n:this.preson[index]
      }
    }
  }
}
let myname = MathName.getName();
alert(myname().n)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="ts-基础系列之-类"><a href="#ts-基础系列之-类" class="header-anchor">#</a> TS 基础系列之-类</h2> <h3 id="声明一个-ts-类"><a href="#声明一个-ts-类" class="header-anchor">#</a> 声明一个 ts 类</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>class Person{
    //声明变量为公有变量
    name:string;
    age:number;
    //构造函数参数遵循函数参数的书写形式
    constructor(name:string,age:number){
        this.name = name;
        this.age = age;
    }
    say(){
        return 'my name is ' + this.name + 'age is ' +this.age;
    }
}
let person = new Person('liushuai',24);
console.log(person.say())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="类的继承"><a href="#类的继承" class="header-anchor">#</a> 类的继承</h3> <p>ts 中类的集成和 ES6 类似</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//继承

class Student extends Person{
    school:string;
    constructor(name:string,age:number,school:string){
        super(name,age);
        this.school = school;
    }
    study(){
        console.log('good good study,day day up ')
    }
}

let student = new Student('liushuai',24,'🏫');
console.log(student.say())
console.log(student.school)
student.study()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="header-anchor">#</a> 公共，私有与受保护的修饰符</h3> <p>和大多数面向对象语言相同，TypeScript 也具有访问修饰符，TypeScript 的访问修饰符有两种：</p> <p>1.public 公有的
2.private 私有的</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>

class Animal{
    //默认为 public 共有的
    public color:string;
    //当成员被标记成 private时，它就不能在声明它的类的外部访问 私有的
    private age:number;
    //与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问 受保护的
    protected name:string;
    constructor(color:string,name:string,age:number){
        this.color = color;
        this.name = name;
        this.age  =age;
    }
    //public 共有的
    public sayColor(){
        return this.color;
    }
    //它就不能在声明它的类的外部访问 私有的
    private sayAge(){
        console.log(this.age)
    }
    //受保护的成员方法，不能再类的外部直接访问
    protected sayName(){
        console.log(this.name)
    }
}
let animal = new Animal('red','dog',1)
class Snake extends Animal{
    constructor(color:string,name:string,age:number){
        super(color,name,age)
    }
    print(){
        return this.color+this.name +this.age//age报错，父类得不到
    }
}
let snake  = new Snake('green','snake',2)
console.log(snake）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h3 id="get、set"><a href="#get、set" class="header-anchor">#</a> get、set</h3> <p>由上面访问修饰符知道，私有属性在外部是无法得到的，并且在子类中无法得到。所以就可以通过 set、get 来对私有属性进行修改和查看。</p> <p>通过 set 和 get 来对 private 修饰的属性提供外部访问接口。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>class Hello {
    private _name : string = 'hello';
    private _age : number;
    tell(){
        return this.name;
    }
    get name() : string {
        return this._name;
    }
    set name(newName : string){
        this._name = newName;
    }
    get age() : number{
        return this._age;
    }
    set age(newAge : number) {
        if(newAge &gt;=200 &amp;&amp; newAge &lt;0){
            alert('请正确填写年龄')
        }else{
            this._age = newAge;
        }
    }
}
var hello = new Hello();
hello.name = 'hello';
hello.age = 200;
console.log(hello.age)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="static"><a href="#static" class="header-anchor">#</a> static</h3> <p>使用 static 声明的属性和方法是静态的，编译成 es5 之后被挂载到构造函数上。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>class Person {
    static name1 : string = 'Person';
    tell(){
        console.log('姓名:' + Person.name1);
    }
}
const p = new Person();
console.log(p.tell());
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h3> <p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>abstract class Demo{
    constructor(public name:string){
    }
    printName():void{
        console.log(this.name + 'name')
    }
    abstract fun1():void;// 必须在派生类中实现
    abstract fun2():void;// 必须在派生类中实现

}
class Demos extends Demo{
    constructor(){
        super('demo1') // 在派生类的构造函数中必须调用 super()
    }
    fun1():void{
        console.log('类的实现')
    }
    fun2():void{
        console.log('第二个类的实现')
    }
    fun3():void{
        console.log('不是抽象类派生的')
    }
}
let demo:Demo;
// let demo = new Demo()//报错不能创建一个抽象类的实例

let demos = new Demos(); // 允许对一个抽象子类进行实例化和赋值
demos.fun1()
// demo.fun3()报错 方法在声明的抽象类中不存在
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h2 id="接口-2"><a href="#接口-2" class="header-anchor">#</a> 接口</h2> <h3 id="初探接口"><a href="#初探接口" class="header-anchor">#</a> 初探接口</h3> <p>接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>interface LabelledValue {
    label: string;
}

function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };
printLabel(myObj);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="可选属性"><a href="#可选属性" class="header-anchor">#</a> 可选属性</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>
interface SquareConfig{
    color?:string;
    size:number;
}
function creatSquare(config:SquareConfig):{color:string,area:number}{
    let newSquare = {color: &quot;white&quot;, area: 100};
    if(config.color){
        newSquare.color = config.color;
    }
    return newSquare;
}

creatSquare({color:'red',size:11})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="函数类型"><a href="#函数类型" class="header-anchor">#</a> 函数类型</h3> <p>函数参数类型统一定义，通过定义一个接口，来实现多个函数使用定制好的规则，而且并不会检查传入参数名是否一样，只会检查传入参数的类型。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>// 定义接口,并且每个数据类型
interface SearchFunc{
    (source:string,substring:string):boolean;
}

//定义变量接受类型

let mysearch : SearchFunc;
// 声明函数,传入的参数名不用和设置名称一样,只要传入的参数类型是一值即可
mysearch = function(src:string,sub:string):boolean{
    // 函数设置了指定返回值为布尔值
    let results = src.search(sub)
    return results&gt;-1;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="可索引的类型"><a href="#可索引的类型" class="header-anchor">#</a> 可索引的类型</h3> <p>与使用接口描述函数类型差不多</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//可索引的类型

interface StringArray{
    [index:number]:string;
}
let myString :StringArray;
// myString = [1,2,3] 报错
myString = ['red','blue','orange']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="混合类型定义接口"><a href="#混合类型定义接口" class="header-anchor">#</a> 混合类型定义接口</h3> <p>一个接口是可以继承多个接口的，
变量名 = &lt;接口名称&gt;{} 这样变量就可以使用接口上面的属性，来定义赋值等</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>// 混合型 的接口定义
interface Counter {
// 一个对象可以同时做为函数和对象使用，并带有额外的属性
(start: number): string;
reset(): void;
// 为了方便演示继承分开写了,可以把所有定义值类型写在这一个里面

}
interface Shape { interval: number; }

// 一个接口继承多个接口 定义好的属性值
interface listCounter extends Counter, Shape{
sideLength: number; // 里面还可以自己在加定义属性值
}
// 混合类型使用
function getCounter(): listCounter {
// 使用Counter声明好的接口,来定义函数
let counter = &lt;listCounter&gt;function (start: number) { };
counter.interval = 123;
counter.reset = function () { };
return counter; // 返回函数体listCounter
}

let c = getCounter();
c(10); // 执行函数传入值
c.reset(); // 执行里面附带的方法,虽然没写内容
c.interval = 5.0; // 赋值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="mixins"><a href="#mixins" class="header-anchor">#</a> Mixins</h2> <p>class Name implements 每个类名{} 把类当成了接口引入，但是要自己去实现接口</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//首先定义了两个类，它们将做为mixins
//可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。
class Disposable{
    isDisposable:boolean;
    dispose(){
        this.isDisposable = true;
    }
}

class ActiveAble{
    isActiveable:boolean;
    deactive(){
        this.isActiveable =true;
    }
}

//下面创建一个类，结合了这两个mixins;使用 implements

class SmartObject implements Disposable,ActiveAble{
    //extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 
    //这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的

    //提前定义一些占位属性
    //Disposable
    isDisposable:boolean = false;
    dispose:()=&gt;void;
    //ActiveAble
    isActiveable:boolean = false;
    deactive:()=&gt;void;
   
   
}

 //最后，把mixins混入定义的类，完成全部实现部分
applyMixins(SmartObject,[Disposable,ActiveAble])

function applyMixins(der:any,base:any[]){
    base.forEach(baseitem=&gt;{
        Object.getOwnPropertyNames(baseitem.prototype).forEach(name=&gt;{
            der.prototype[name] = baseitem.prototype[name]
        })
    })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <h3 id="认识泛型"><a href="#认识泛型" class="header-anchor">#</a> 认识泛型</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//首先写一个函数会返回任何传入它的number。

// function helloNum (arg:number):number{
//     return arg;
// }

//需求又改为 函数会返回任何传入它的值，第一反应应该是想到any

// function helloNum (arg:any):any{
//     return arg;
// }

//但是问题有了他没有明显的规范，容易出现转换错误

//那么9⃣就的使用泛型  泛型需要 &lt;T&gt;

function helloNum &lt;T&gt;( arg:T):T{
    return arg;
}
//使用的好处,需要什么类型指定什么类型

let helloNumString = helloNum&lt;string&gt;('hello Mike')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="应用泛型"><a href="#应用泛型" class="header-anchor">#</a> 应用泛型</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//泛型的应用

//泛型不一定&lt;&gt;里非得写&lt;T&gt;;可以随意写入大写&lt;K&gt;;通常是用&lt;T&gt;

function helloStr&lt;T&gt;(arg:T):T{
    //console.log(arg.length)//这里会报错
    return arg;
}

//而我们这么写

function helloArr&lt;T&gt;(args:T[]):T[]{

    console.log(args.length)//这里不会报错
    return args;
}

//总结泛型会根据你传递的类型而决定他会具有哪些属性
let list:Array&lt;string&gt;=helloArr&lt;string&gt;(['1','2','3'])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="泛型类型"><a href="#泛型类型" class="header-anchor">#</a> 泛型类型</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//泛型类型

function helloDemo&lt;T&gt;(arg:T):T{
    return arg;
}

let myHelloDemo:&lt;K&gt;(arg:K)=&gt;K = helloDemo;
//或者
let myHelloDemo1:{&lt;T&gt;(arg:T):T} = helloDemo;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="泛型类"><a href="#泛型类" class="header-anchor">#</a> 泛型类</h3> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//泛型类
class  HelloNumber&lt;T&gt;{
    Ten:T;
    add:(x:T,y:T)=&gt;T;
}

var myHelloNumber = new HelloNumber&lt;number&gt;();
myHelloNumber.Ten = 10;

myHelloNumber.add = function(x,y){
    return x+y;
}
alert(myHelloNumber.Ten)
alert(
    myHelloNumber.add(10,10))
    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="module-模式和-namespace"><a href="#module-模式和-namespace" class="header-anchor">#</a> Module 模式和 namespace</h2> <p>Module 模式：1 模块话，可重用 2.封装变量与函数</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>interface StringValidator{
 isAcceptable(s : string) : boolean;
}
let lettersRegexp = (str) =&gt; /^[A-Za-z]+$/.test(str);
let numberRegexp = (str) =&gt; /^[0-9]+$/.test(str);
class LetterOnlyValidator implements StringValidator{
 
isAcceptable(s : string) : boolean{
    return lettersRegexp(s);
}
}
class ZipCodeValidor implements StringValidator{
 isAcceptable(s:string):boolean{
     return s.length == 5 &amp;&amp; numberRegexp(s);
 }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>每一次使用在这里都需要调用。</p> <p>TypeScript 中早期使用 module 来作为模块化。</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>//module.ts
export module Validation{
     export interface StringValidator{
         isAcceptable(s : string) : boolean;
     }
     let lettersRegexp = (str) =&gt; /^[A-Za-z]+$/.test(str);
     let numberRegexp = (str) =&gt; /^[0-9]+$/.test(str);
     export class LetterOnlyValidator implements StringValidator{
         isAcceptable(s : string):boolean {
             return lettersRegexp(s);
         }
     }
     export class ZipCodeValidor implements StringValidator{
         isAcceptable(s : string) : boolean{
             return numberRegexp(s);
         }
     }
 }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>由于 1.5 版本的更新和 ES6 的出现，把 module 改成了 namespace</p> <div class="language-plain line-numbers-mode"><pre class="language-text"><code>namespace Validation{
    export interface StringValidator{
        isAcceptable(s : string) : boolean;
    }
    const lettersRegexp = (str) =&gt; /^[A-Za-z]+$/.test(str);
    const numberRegexp = (str) =&gt; /^[0-9]+$/.test(str);
    export class LettersOnlyValidator implements StringValidator{
        isAcceptable(s : string) : boolean {
            return lettersRegexp(s);
        }
    }
    export class ZipCodeValidator implements StringValidator{
        isAcceptable(s : string) :boolean {
            return numberRegexp(s);
        }
  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/wendaoshuai66/blogs/edit/master/docs/blog/TypeScript使用手册.md" target="_blank" rel="noopener noreferrer">本文源码地址</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2/5/2020, 1:10:59 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/Redux原理.html" class="prev">
        探索 Redux 原理
      </a></span> <span class="next"><a href="/blog/NodeJS入门.html">
        NodeJS 入门
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ae0effdb.js" defer></script><script src="/assets/js/2.1f0a0a54.js" defer></script><script src="/assets/js/26.4adf545a.js" defer></script>
  </body>
</html>
